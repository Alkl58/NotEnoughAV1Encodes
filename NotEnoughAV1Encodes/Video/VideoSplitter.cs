using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Management;
using System.Threading;

namespace NotEnoughAV1Encodes.Video
{
    class VideoSplitter
    {
        private Queue.QueueElement queueElement = new();
        public void Split(Queue.QueueElement _queueElement, CancellationToken _token)
        {
            queueElement = _queueElement;

            if (queueElement.ChunkingMethod == 0)
            {
                // Equal Chunking
                FFmpegChunking(_token);
            }
            else if(queueElement.ChunkingMethod == 1)
            {
                // PySceneDetect
                PySceneDetect(_token);
            }
        }

        private void PySceneDetect(CancellationToken _token)
        {
            // Skip Scene Detect if the file already exist
            if (!File.Exists(Path.Combine(Global.Temp, "NEAV1E", queueElement.UniqueIdentifier, "splits.txt")))
            {
                // Detects the Scenes with PySceneDetect
                Process pySceneDetect = new();
                ProcessStartInfo startInfo = new()
                {
                    WindowStyle = ProcessWindowStyle.Hidden,
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    RedirectStandardError = true,
                    FileName = "cmd.exe",
                    WorkingDirectory = Path.Combine(Directory.GetCurrentDirectory(), "Apps", "pyscenedetect"),
                    Arguments = "/C scenedetect -i \"" + queueElement.Input + "\" -o \"" + Path.Combine(Global.Temp, "NEAV1E", queueElement.UniqueIdentifier) + '\u0022' + " detect-content -t " + queueElement.PySceneDetectThreshold.ToString() + " list-scenes"
                };
                pySceneDetect.StartInfo = startInfo;

                pySceneDetect.Start();

                _token.Register(() => { KillProcessAndChildren(pySceneDetect.Id); });

                StreamReader sr = pySceneDetect.StandardError;

                while (!sr.EndOfStream)
                {
                    try
                    {
                        queueElement.Status = "Splitting - " + sr.ReadLine();
                    }
                    catch { }
                }

                pySceneDetect.WaitForExit();

                sr.Close();

                if (!_token.IsCancellationRequested)
                {
                    PySceneDetectParse();
                }
            }
        }

        private void PySceneDetectParse()
        {
            // Reads first line of the csv file generated by pyscenedetect
             string line = File.ReadLines(Path.Combine(Global.Temp, "NEAV1E", queueElement.UniqueIdentifier, Path.GetFileNameWithoutExtension(queueElement.Input) + "-Scenes.csv")).First();

            // Splits the line after "," and skips the first line, then adds the result to list
            List<string> scenes = line.Split(',').Skip(1).ToList();

            // Temporary value used for creating the ffmpeg command line
            string previousScene = "00:00:00.000";

            List<string> FFmpegArgs = new();

            // Iterates over the list of time codes and creates the args for ffmpeg
            foreach (string sc in scenes)
            {
                FFmpegArgs.Add("-ss " + previousScene + " -to " + sc);
                previousScene = sc;
            }

            // Has to be last, to "tell" ffmpeg to seek / encode until end of video
            FFmpegArgs.Add("-ss " + previousScene);

            // Writes splitting arguments to text file
            foreach (string lineArg in FFmpegArgs)
            {
                using (StreamWriter sw = File.AppendText(Path.Combine(Global.Temp, "NEAV1E", queueElement.UniqueIdentifier, "splits.txt")))
                {
                    sw.WriteLine(lineArg);
                    sw.Close();
                }
            }
        }

        private void FFmpegChunking(CancellationToken _token)
        {
            // Skips Splitting of already existent
            if (!File.Exists(Path.Combine(Global.Temp, "NEAV1E", queueElement.UniqueIdentifier, "splitted.log")))
            {
                // Create Chunks Folder
                Directory.CreateDirectory(Path.Combine(Global.Temp, "NEAV1E", queueElement.UniqueIdentifier, "Chunks"));

                // Generate Command
                string ffmpeg_command = "/C ffmpeg.exe";
                ffmpeg_command += " -y -i " + '\u0022' + queueElement.Input + '\u0022';
                ffmpeg_command += " -reset_timestamps 1 -map_metadata -1 -sn -an";

                if (queueElement.ChunkingMethod == 0)
                {
                    ffmpeg_command += " -c:v libx264 -preset ultrafast -crf 0";
                }
                else if(queueElement.ChunkingMethod == 1)
                {
                    ffmpeg_command += " -c:v ffv1 -level 3 -threads 4 -coder 1 -context 1 -slicecrc 0 -slices 4";
                }
                else if (queueElement.ChunkingMethod == 2)
                {
                    ffmpeg_command += " -c:v utvideo";
                }
                else if (queueElement.ChunkingMethod == 3)
                {
                    ffmpeg_command += " -c:v copy";
                }

                if (queueElement.ChunkingMethod != 3)
                {
                    ffmpeg_command += " -sc_threshold 0 -g " + queueElement.ChunkLength.ToString();
                    ffmpeg_command += " -force_key_frames " + '\u0022' + "expr:gte(t, n_forced * " + queueElement.ChunkLength.ToString() + ")" + '\u0022';
                }

                ffmpeg_command += " -segment_time " + queueElement.ChunkLength.ToString() + " -f segment \"";
                ffmpeg_command += Path.Combine(Global.Temp, "NEAV1E", queueElement.UniqueIdentifier, "Chunks", "split%6d.mkv") + "\"";

                // Start Splitting
                Process chunkingProcess = new();
                ProcessStartInfo startInfo = new()
                {
                    WindowStyle = ProcessWindowStyle.Hidden,
                    FileName = "cmd.exe",
                    RedirectStandardInput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true,
                    WorkingDirectory = Path.Combine(Directory.GetCurrentDirectory(), "Apps", "FFmpeg"),
                    Arguments = ffmpeg_command
                };
                chunkingProcess.StartInfo = startInfo;

                _token.Register(() => { try { chunkingProcess.StandardInput.Write("q"); } catch { } });

                // Start Process
                chunkingProcess.Start();

                // Get launched Process ID
                int tempPID = chunkingProcess.Id;

                // Add Process ID to Array, inorder to keep track / kill the instances
                Global.LaunchedPIDs.Add(tempPID);

                StreamReader sr = chunkingProcess.StandardError;
                while (!sr.EndOfStream)
                {
                    int processedFrames = Global.GetTotalFramesProcessed(sr.ReadLine());
                    if (processedFrames != 0)
                    {
                        queueElement.Progress = Convert.ToDouble(processedFrames);
                        queueElement.Status = "Splitting - " + ((decimal)queueElement.Progress / queueElement.FrameCount).ToString("0.00%");
                    }
                }

                // Wait for Exit
                chunkingProcess.WaitForExit();

                // Get Exit Code
                int exit_code = chunkingProcess.ExitCode;

                // Remove PID from Array after Exit
                Global.LaunchedPIDs.RemoveAll(i => i == tempPID);

                // Write Save Point
                if (chunkingProcess.ExitCode == 0 && _token.IsCancellationRequested == false)
                {
                    FileStream _finishedLog = File.Create(Path.Combine(Global.Temp, "NEAV1E", queueElement.UniqueIdentifier, "splitted.log"));
                    _finishedLog.Close();
                }
            }
        }

        private static void KillProcessAndChildren(int pid)
        {
            ManagementObjectSearcher searcher = new ManagementObjectSearcher
              ("Select * From Win32_Process Where ParentProcessID=" + pid);
            ManagementObjectCollection moc = searcher.Get();
            foreach (ManagementObject mo in moc)
            {
                KillProcessAndChildren(Convert.ToInt32(mo["ProcessID"]));
            }
            try
            {
                Process proc = Process.GetProcessById(pid);
                proc.Kill();
            }
            catch (ArgumentException)
            {
                // Process already exited.
            }
        }
    }
}
